# FILE: configs/calib/method/adc.yaml
# ==============================================================================
# ðŸ”§ ADC (Analog-to-Digital Conversion) â€” Method Config (v1.1)
# ------------------------------------------------------------------------------
# Purpose
#   Apply offset & gain normalization (PRNU), optional reference-pixel / overscan
#   correction and response linearization, then (optionally) re-quantize to a
#   target bit-depth/dtype for downstream calibration (dark/flat/CDS).
#
# Usage
#   Composed by your calibration chain as the first stage.
#   Examples:
#     spectramind calibrate calib.method.adc.offset.method=per_channel \
#       calib.method.adc.offset.table_path=data/calib/adc/offsets_per_channel.npy
#     spectramind calibrate calib.method.adc.linearization.method=lut \
#       calib.method.adc.linearization.lut_path=data/calib/adc/lin_lut.npy
# ==============================================================================

_meta:
  schema_version: "1.1.0"
  last_updated: "${now:%Y-%m-%d}"

adc:
  enabled: true

  # ---------------------------------------------------------------------------
  # Detector I/O & quantization
  # ---------------------------------------------------------------------------
  detector:
    name: "ArielSimCam"
    bit_depth_in: 16                 # raw input nominal bit depth (DN range)
    bit_depth_out: 16                # target depth if re-quantizing to int dtype
    dtype_out: "float32"             # "float32" | "float16" | "uint16" | "uint32"
    conversion_gain_e_per_adu: 1.0   # electrons per DN (used if converting units)
    saturation_level_e: 180000.0     # info-only; QC/diagnostics may use this

  # ---------------------------------------------------------------------------
  # Overscan & per-amplifier options (optional)
  # ---------------------------------------------------------------------------
  overscan:
    enabled: false
    # Define 2D boxes in pixel coords for overscan estimation.
    # Example regions: keys are labels (e.g., amp IDs), values are {y:[y0,y1], x:[x0,x1]} (inclusive bounds).
    regions:
      # A: { y: [0, 2047], x: [2048, 2095] }
    strategy: "median"               # "median" | "polyfit"
    poly_order: 1
    subtract_per_amp: true

  amplifiers:
    enabled: false
    layout: ["A", "B", "C", "D"]
    # Science regions per amplifier (no overscan region here)
    regions:
      # A: { y: [0, 2047], x: [0, 1023] }
    trim_overscan: true
    per_amp_gain:
      enabled: false
      table_path: "data/calib/adc/gain_per_amp.npy"   # per-amp scalar gains

  # ---------------------------------------------------------------------------
  # Offset correction (bias removal)
  #   Order: reference_pixel (if enabled) â†’ table/map/global
  # ---------------------------------------------------------------------------
  offset:
    method: "per_channel"            # "none" | "global" | "per_channel" | "per_pixel"
    # Global constant (DN) if method == "global"
    value_adu: 0.0
    # Per-channel offsets (NPY shape [C]); ignored if input is 2D (assumed C=1)
    table_path: "data/calib/adc/offsets_per_channel.npy"
    # Per-pixel offsets (NPY HxW or CxHxW) if method == "per_pixel"
    map_path: "data/calib/adc/offsets_map.npy"

    reference_pixel:
      use: false
      strategy: "border_mean"        # "border_mean" | "mask_mean"
      border: { top: 4, bottom: 4, left: 4, right: 4 }
      mask_path: "data/calib/adc/reference_pixels_mask.npy"

  # ---------------------------------------------------------------------------
  # Gain / PRNU correction (multiplicative)
  #   Applied as: frame <- frame / gain_map
  # ---------------------------------------------------------------------------
  gain:
    method: "per_channel"            # "none" | "global" | "per_channel" | "per_pixel"
    value: 1.0
    table_path: "data/calib/adc/gains_per_channel.npy"   # [C]
    prnu_map_path: "data/calib/adc/prnu_map.npy"         # HxW or CxHxW
    epsilon: 1.0e-6
    renormalize_to_mean_one: true    # rescale gains so mean(gain)=1 after load

  # ---------------------------------------------------------------------------
  # Linearization (response curve / non-linearity correction)
  #   Converts non-linear DN response to linear space.
  # ---------------------------------------------------------------------------
  linearization:
    method: "none"                   # "none" | "lut" | "poly"
    # LUT: 1D mapping input DN -> linearized DN
    lut_path: "data/calib/adc/linearization_lut.npy"
    lut_interp: "linear"             # "nearest" | "linear"
    # Polynomial: y_lin = c0 + c1*x + c2*x^2 + ... with x = raw_DN / poly_norm_adu
    poly_coeffs: [1.0, 0.0, 0.0]
    poly_norm_adu: 65535.0

  # ---------------------------------------------------------------------------
  # Re-quantization / clamping
  # ---------------------------------------------------------------------------
  quantization:
    clip:
      min_adu: 0.0
      max_adu: 65535.0
    rounding: "nearest"              # "nearest" | "floor" | "ceil" | "stochastic"
    enforce_range: true              # if casting to integer dtype_out
    # After offset/gain/lin, clamp small negatives if desired (preserve noise margin)
    post_subtraction_clamp:
      enabled: true
      min_adu: -5.0

  # ---------------------------------------------------------------------------
  # Quality control (soft guards; do not mutate data)
  # ---------------------------------------------------------------------------
  qc:
    enabled: true
    histogram_after:
      bins: 256
      max_zero_frac: 0.15            # fraction at exact 0 after processing
      max_saturated_frac: 0.10       # fraction at max DN after processing
    stats_after:
      mean_adu_range: [50.0, 50000.0]
      std_adu_max: 20000.0
    on_fail: "warn"                  # "warn" | "raise" | "skip"

  # ---------------------------------------------------------------------------
  # IO mapping (pipeline/executor contract)
  # ---------------------------------------------------------------------------
  io:
    input_key: "raw_frames"
    output_key: "adc_corrected"
    # Optional: write overscan/bias structures for debugging
    debug_keys:
      overscan_estimate: "adc_overscan_est"
      bias_map: "adc_bias_map"

  # ---------------------------------------------------------------------------
  # Diagnostics & logging
  # ---------------------------------------------------------------------------
  diagnostics:
    enabled: true
    save_samples: 2
    output_dir: "${oc.env:RUN_DIR, runs}/diag/adc"
    save_images: false
    filename_prefix: "adc"
    plot_format: "png"

  logging:
    level: "INFO"                   # "DEBUG" | "INFO" | "WARNING" | "ERROR"

  # ---------------------------------------------------------------------------
  # Runtime & validation
  # ---------------------------------------------------------------------------
  runtime:
    num_workers: 2
    seed: 1337

  validation:
    require_existing_paths: true    # if method uses files, they must exist
    check_shape_compatibility: true # verify [C,H,W] vs loaded maps
    assert_finite_output: true

  notes: |
    â€¢ Order of operations: reference-pixel (if enabled) â†’ offset â†’ gain(PRNU) â†’ linearization
      â†’ clamping/quantization. Overscan/per-amplifier corrections can precede offset/gain
      if enabled.
    â€¢ Keep units consistent; if you convert to/from electrons for diagnostics, use
      detector.conversion_gain_e_per_adu consistently.
    â€¢ Renormalizing gain maps to mean 1 avoids global flux scale shifts into downstream stages.
