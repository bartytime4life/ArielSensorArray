# FILE: configs/calib/method/adc.yaml
# ==============================================================================
# ðŸ”§ ADC (Analog-to-Digital Conversion) â€” Method Config (v1.3)
# ------------------------------------------------------------------------------
# Purpose
#   Apply offset & gain normalization (PRNU), optional reference-pixel / overscan
#   correction, response linearization, and (optionally) re-quantize outputs for
#   downstream calibration (dark â†’ flat â†’ CDS â†’ photometry â†’ trace â†’ phase).
#
# Hydra usage (examples)
#   spectramind calibrate calib.method.adc.offset.method=per_channel \
#     calib.method.adc.offset.table_path=data/calib/adc/offsets_per_channel.npy
#   spectramind calibrate calib.method.adc.linearization.method=lut \
#     calib.method.adc.linearization.lut_path=data/calib/adc/lin_lut.npy
#   spectramind calibrate calib.method.adc.overscan.enabled=true \
#     calib.method.adc.overscan.regions.A.y='[0,2047]' calib.method.adc.overscan.regions.A.x='[2048,2095]'
# ==============================================================================

_meta:
  schema_version: "1.3.0"
  last_updated: "${now:%Y-%m-%d}"

adc:
  enabled: true

  # ---------------------------------------------------------------------------
  # Detector I/O & quantization
  # ---------------------------------------------------------------------------
  detector:
    name: "ArielSimCam"
    bit_depth_in: 16                       # raw DN nominal depth
    bit_depth_out: 16                      # if re-quantizing to integer dtype
    dtype_out: "float32"                   # "float32" | "float16" | "uint16" | "uint32"
    conversion_gain_e_per_adu: 1.0         # e-/DN for optional unit conversions
    saturation_level_dn: 65535             # DN saturation (if known)
    saturation_level_e: 180000.0           # e- saturation (informative)

  # ---------------------------------------------------------------------------
  # Reference pixels & overscan (optional; typically before offset/gain)
  # ---------------------------------------------------------------------------
  reference_pixel:
    use: false
    # strategy: "border_mean" | "mask_mean" | "strip_per_col" | "strip_per_row"
    strategy: "border_mean"
    border: { top: 4, bottom: 4, left: 4, right: 4 }
    mask_path: "data/calib/adc/reference_pixels_mask.npy"
    # Remove column/row bias using ref pixel strips
    strip:
      robust:
        sigma_clip: 4.0
        max_iters: 2
      poly_order: 0                   # 0=mean of strip; >0 fits slow trend along the strip

  overscan:
    enabled: false
    # 2D boxes in pixel coords (inclusive). Values as {y:[y0,y1], x:[x0,x1]}
    regions:
      # A: { y: [0, 2047], x: [2048, 2095] }
    strategy: "median"                 # "median" | "polyfit" (fit along columns)
    poly_order: 1
    subtract_per_amp: true
    robust:
      sigma_clip: 4.0
      max_iters: 2

  # ---------------------------------------------------------------------------
  # Per-amplifier handling (optional)
  # ---------------------------------------------------------------------------
  amplifiers:
    enabled: false
    layout: ["A", "B", "C", "D"]
    # science (trim) regions per amplifier (no overscan in these)
    regions:
      # A: { y: [0, 2047], x: [0, 1023] }
    trim_overscan: true
    per_amp_gain:
      enabled: false
      table_path: "data/calib/adc/gain_per_amp.npy"   # per-amp scalars
    per_amp_offset:
      enabled: false
      table_path: "data/calib/adc/offset_per_amp.npy" # per-amp biases (DN)

  # ---------------------------------------------------------------------------
  # Offset correction (bias removal)
  #   Order within ADC: reference_pixel/overscan â†’ offset â†’ gain â†’ linearization
  # ---------------------------------------------------------------------------
  offset:
    method: "per_channel"                # "none" | "global" | "per_channel" | "per_pixel"
    # DN constant if method=="global"
    value_adu: 0.0
    # Per-channel offsets [C] if method=="per_channel"
    table_path: "data/calib/adc/offsets_per_channel.npy"
    # Per-pixel offsets (HxW or CxHxW) if method=="per_pixel"
    map_path: "data/calib/adc/offsets_map.npy"
    # Optional auto-black (fallback when tables missing): estimate constant bias
    auto_black:
      enabled: false
      # "roi" | "hist_peak"
      method: "hist_peak"
      roi: { y: [0, 63], x: [0, 63] }
      hist:
        bins: 2048
        smooth_sigma_bins: 3.0

  # ---------------------------------------------------------------------------
  # Gain / PRNU correction (multiplicative) â€” frame <- frame / gain_map
  # ---------------------------------------------------------------------------
  gain:
    method: "per_channel"                # "none" | "global" | "per_channel" | "per_pixel"
    value: 1.0
    table_path: "data/calib/adc/gains_per_channel.npy"   # [C]
    prnu_map_path: "data/calib/adc/prnu_map.npy"         # HxW or CxHxW
    epsilon: 1.0e-6
    renormalize_to_mean_one: true        # rescale gains so mean(gain)=1 after load
    # Optional large-scale illumination field to divide out (vignetting pre-flat)
    illumination:
      enabled: false
      method: "spline2d"                 # "poly2d" | "spline2d" | "gaussian"
      spline: { grid: [24, 24] }
      poly:   { degree_x: 2, degree_y: 2 }
      gaussian: { sigma_px: 25.0 }
      robust:
        sigma_clip: 3.0
        max_iters: 3
      renormalize_to_mean_one: true

  # ---------------------------------------------------------------------------
  # Linearization (response curve / non-linearity correction)
  #   Converts non-linear DN response to linear space.
  # ---------------------------------------------------------------------------
  linearization:
    method: "none"                       # "none" | "lut" | "poly"
    # LUT: DN_in â†’ DN_lin (1D)
    lut_path: "data/calib/adc/linearization_lut.npy"
    lut_interp: "linear"                 # "nearest" | "linear"
    # Polynomial: y_lin = c0 + c1*x + c2*x^2 + ... with x = raw_DN / poly_norm_adu
    poly_coeffs: [1.0, 0.0, 0.0]
    poly_norm_adu: 65535.0
    # Optional per-amp LUTs override (if geometry differs)
    per_amp:
      enabled: false
      lut_dir: "data/calib/adc/lin_luts_per_amp"        # e.g., A.npy, B.npy, ...

  # ---------------------------------------------------------------------------
  # Smear / blooming / bleed mitigation (optional)
  # ---------------------------------------------------------------------------
  smear:
    enabled: false
    # Column smear model: subtract fraction of column mean
    column_fraction: 0.0               # e.g., 0.001
    # Row smear model: subtract fraction of row mean
    row_fraction: 0.0

  blooming:
    enabled: false
    # treat saturated runs by tapering neighboring pixels
    taper_kernel: "gaussian3"          # "median4" | "gaussian3"
    grow_radius_px: 1

  # ---------------------------------------------------------------------------
  # Saturation & masks (propagated to downstream)
  # ---------------------------------------------------------------------------
  saturation:
    enabled: true
    threshold_dn: 65500
    write_mask_key: "adc_saturation_mask"   # added under io.output_key if enabled

  bad_pixels:
    enabled: false
    bpm_path: "data/calib/masks/bad_pixel_map.npy"
    replace_mode: "median4"            # "median4" | "median8" | "gaussian3"
    max_replace_fraction: 0.05

  # ---------------------------------------------------------------------------
  # Re-quantization / clamping
  # ---------------------------------------------------------------------------
  quantization:
    clip:
      min_adu: 0.0
      max_adu: 65535.0
    rounding: "nearest"                # "nearest" | "floor" | "ceil" | "stochastic"
    enforce_range: true                # if casting to integer dtype_out
    # After offset/gain/lin, clamp small negatives (preserve noise margin)
    post_subtraction_clamp:
      enabled: true
      min_adu: -5.0

  # ---------------------------------------------------------------------------
  # Quality control (soft guards; do not mutate data)
  # ---------------------------------------------------------------------------
  qc:
    enabled: true
    # Histogram sanity post-ADC
    histogram_after:
      bins: 256
      max_zero_frac: 0.15              # fraction exactly at 0
      max_saturated_frac: 0.10         # fraction at top of range
    # Frame stats sanity
    stats_after:
      mean_adu_range: [50.0, 50000.0]
      std_adu_max: 20000.0
    # Optional per-amp parity checks (mean/median deltas between amps)
    per_amp:
      enabled: false
      max_mean_delta_frac: 0.05
      max_median_delta_frac: 0.05
    on_fail: "warn"                    # "warn" | "raise" | "skip"

  # ---------------------------------------------------------------------------
  # IO mapping (pipeline/executor contract)
  # ---------------------------------------------------------------------------
  io:
    input_key: "raw_frames"
    output_key: "adc_corrected"
    # Optional debug artifacts written under output_key
    debug_keys:
      overscan_estimate: "adc_overscan_est"
      bias_map: "adc_bias_map"
      gain_map_used: "adc_gain_map_used"
      lin_applied: "adc_lin_applied"

  # ---------------------------------------------------------------------------
  # Diagnostics & logging
  # ---------------------------------------------------------------------------
  diagnostics:
    enabled: true
    save_samples: 2
    output_dir: "${oc.env:RUN_DIR, runs}/diag/adc"
    save_images: false
    filename_prefix: "adc"
    plot_format: "png"

  logging:
    level: "INFO"                     # "DEBUG" | "INFO" | "WARNING" | "ERROR"

  # ---------------------------------------------------------------------------
  # Runtime & validation
  # ---------------------------------------------------------------------------
  runtime:
    num_workers: 2
    seed: 1337

  validation:
    require_existing_paths: true      # if a method uses files, they must exist
    check_shape_compatibility: true   # verify [C,H,W] vs loaded maps/LUTs
    assert_finite_output: true

  notes: |
    â€¢ Order of ops: reference/overscan â†’ offset â†’ gain(PRNU) â†’ linearization â†’
      smear/bloom corrections â†’ clamping/quantization.
    â€¢ Enable per-amp handling when detector electronics differ by quadrant/amp.
    â€¢ Renormalize PRNU/gains to mean 1 to avoid global flux scaling drift.
    â€¢ Keep unit consistency if converting between DN and electrons; use
      detector.conversion_gain_e_per_adu consistently across stages.
