# configs/calib/method/temperature.yaml
# ==============================================================================
# 🌡️ Temperature Drift Correction — Method Config (Upgraded, Mission-Grade)
# Purpose
#   Compensate detector/electronics gain & bias drift, and optics-induced
#   wavelength calibration offsets driven by thermal fluctuations. Supports
#   multi-sensor telemetry fusion, per-instrument models (FGS1 vs AIRS),
#   hysteresis/time-constant dynamics, uncertainty propagation, and rich
#   diagnostics suitable for audit/CI.
# Usage
#   Composed by calib/{nominal,fast,strict}.yaml in the calibration kill chain.
#   Example overrides:
#     spectramind calibrate calib.method.temperature.enabled=false
#     spectramind calibrate calib.method.temperature.models.fgs1.gain_model.type=polynomial
# ==============================================================================

temperature:
  enabled: true

  # ---------------------------------------------------------------------------
  # Telemetry ingestion (multi-sensor support)
  # ---------------------------------------------------------------------------
  telemetry:
    file: "calib/temperature/telemetry.csv"  # CSV/Parquet with time + sensors
    format: "csv"                             # csv | parquet
    time:
      column: "timestamp"                     # time column
      unit: "s"                               # s | ms | iso8601
      tz: "UTC"
    sensors:
      # Define any number of sensors and map to physical roles
      detector_temp:
        column: "detector_C"
        unit: "C"                             # C | K
        role: "detector"                      # detector | optics | ambient | board
      optics_temp:
        column: "optics_C"
        unit: "C"
        role: "optics"
      board_temp:
        column: "board_C"
        unit: "C"
        role: "board"
    interpolation:
      method: "linear"                        # linear | spline | nearest
      order: 3                                # for spline
      fill_extrapolate: true                  # allow limited extrapolation
      max_gap: 120.0                          # s; gaps > max_gap are masked
      smoothing:
        enabled: true
        window_s: 15.0                        # moving-average (seconds)
        method: "ma"                          # ma | savgol
        savgol:
          window: 31
          polyorder: 2

  # ---------------------------------------------------------------------------
  # Thermal dynamics (first-order response + hysteresis)
  # Models true effective temperatures seen by electronics/optics
  # ---------------------------------------------------------------------------
  dynamics:
    enabled: true
    detector:
      time_constant_s: 60.0                   # RC-like lag to telemetry
      hysteresis_C: 0.05                      # small hysteresis band
    optics:
      time_constant_s: 180.0
      hysteresis_C: 0.02

  # ---------------------------------------------------------------------------
  # Per-instrument correction models (FGS1 vs AIRS)
  # ΔT = (effective_temp - reference_temp)
  # ---------------------------------------------------------------------------
  models:
    fgs1:
      reference_temp_C: 20.0
      gain_model:
        type: "linear"                        # linear | polynomial | lookup
        coefficients: [1.0, 0.002]            # gain = a0 + a1*ΔT (+ a2*ΔT^2 ...)
        lookup_table: null                    # optional .npy table [ΔT, gain]
      bias_model:
        type: "linear"
        coefficients: [0.0, 0.01]             # DN offset per °C
        lookup_table: null
      wavelength_drift:
        enabled: true
        model: "polynomial"                   # polynomial | spline | lookup
        order: 2
        coefficients: [0.0, 0.05, -0.002]     # Δλ [nm] per ΔT terms
        lookup_table: null
      apply_scope:
        frames: "all"                         # all | in_transit | oot
        channels: "all"                       # index list or "all"

    airs:
      reference_temp_C: 20.0
      gain_model:
        type: "polynomial"
        coefficients: [1.0, 0.001, 1.5e-4]
        lookup_table: null
      bias_model:
        type: "linear"
        coefficients: [0.0, 0.008]
        lookup_table: null
      wavelength_drift:
        enabled: true
        model: "spline"
        order: 3
        coefficients: []                      # unused for spline
        lookup_table: null
      apply_scope:
        frames: "all"
        channels: "all"

  # ---------------------------------------------------------------------------
  # Global fallback correction map (e.g., from lab calibration)
  # If enabled, supersedes parametric models where coverage exists.
  # ---------------------------------------------------------------------------
  correction_map:
    enabled: false
    path: "calib/temperature/correction_table.npy"  # structured LUT:
                                                    # keys: ΔT, gain, bias, Δλ
    priority: "map_over_models"                     # map_over_models | blend
    blend_weight: 0.6                               # if priority=blend

  # ---------------------------------------------------------------------------
  # Outlier handling & quality gates on telemetry
  # ---------------------------------------------------------------------------
  quality:
    outliers:
      sigma_clip: 4.0
      max_iter: 5
      isolate_sensor: true              # clip per-sensor independently
    plausibility_limits:
      detector_C: [-30.0, 50.0]
      optics_C: [-30.0, 50.0]
    missing_policy: "mask"              # mask | interpolate | fail
    allow_large_extrapolation: false

  # ---------------------------------------------------------------------------
  # Uncertainty propagation (optional)
  # Provide per-sensor σ_T to derive σ_gain, σ_bias, σ_Δλ by Jacobian.
  # ---------------------------------------------------------------------------
  uncertainty:
    enabled: true
    sensor_sigma_C:
      detector_temp: 0.02               # °C (1σ)
      optics_temp: 0.02
    propagate_to:
      gain: true
      bias: true
      wavelength: true
    export_maps: true                   # save σ maps alongside corrections

  # ---------------------------------------------------------------------------
  # Execution controls & overrides for profiles
  # These allow nominal/fast/strict to dial cost/accuracy.
  # ---------------------------------------------------------------------------
  profile_overrides:
    fast:
      telemetry.interpolation.smoothing.enabled: true
      telemetry.interpolation.smoothing.window_s: 8.0
      dynamics.detector.time_constant_s: 30.0
      dynamics.optics.time_constant_s: 90.0
      uncertainty.enabled: false
    strict:
      telemetry.interpolation.method: "spline"
      telemetry.interpolation.order: 3
      telemetry.interpolation.smoothing.method: "savgol"
      dynamics.detector.time_constant_s: 120.0
      dynamics.optics.time_constant_s: 300.0
      uncertainty.enabled: true

  # ---------------------------------------------------------------------------
  # Diagnostics & logging
  # ---------------------------------------------------------------------------
  diagnostics:
    save_plots: true
    plot:
      temps_time_series: true           # raw vs smoothed vs effective temps
      deltaT_vs_corrections: true       # ΔT vs gain/bias/Δλ curves
      residual_histograms: true
      per_instrument_panels: true
    export:
      corrected_frames_preview: true    # small subset for sanity checks
      metadata_json: true               # write applied coefficients, refs
      csv_summary: "calib/temperature/summary.csv"
    audit_flags:
      fail_on_telemetry_gap: false
      warn_on_extrapolation: true
      warn_on_plausibility_violation: true

  # ---------------------------------------------------------------------------
  # Notes & best practices
  # ---------------------------------------------------------------------------
  notes: |
    This module aligns temperature telemetry to science frames, models thermal
    response dynamics (lag/hysteresis), and applies per-instrument corrections
    for gain, bias, and wavelength drift. For highest fidelity:
      • Fit coefficients from lab calibration (flats, arcs) and in-flight flats.
      • Validate Δλ correction with arc/sky lines (AIRS) and photometric color tests (FGS1).
      • Use strict profile to enable spline interpolation and uncertainty export.
      • Guard against telemetry gaps/extrapolation with quality gates.
      • Prefer correction_map when dense lab LUTs exist; otherwise parametric models.