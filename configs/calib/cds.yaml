FILE: configs/calib/cds.yaml

==============================================================================

CORRELATED DOUBLE SAMPLING (CDS) — SpectraMind V50 Calibration Kill Chain (stage 04, upgraded)

——————————————————————————

Purpose

Suppress kTC/reset noise and low-frequency drifts by differencing suitably

paired reads/frames. Supports:

• reset_signal   — true CDS using RESET → SIGNAL pairing

• frame_diff     — Fn − F(n−1) sequential differencing

• rolling_window — subtract local baseline in a temporal window

• odd_even       — odd vs even index differencing (useful for periodic resets)

• reference_frame— subtract a fixed or running reference frame/stack

Adds robust pairing rules, temporal cleanup, outlier suppression, and scale normalization.



Contract

In : io.input_key   (typically produced by configs/calib/flat.yaml)

Out: io.output_key  (consumed by photometry/trace stages)



Notes

• Geometry-agnostic: works for [B,H,W] or [B,C,H,W] tensors.

• May rely on per-frame metadata (timestamps, indices, reset flags).

• If a required metadata key is missing, behavior follows validation.

• Numerically safe (NaN/Inf guards) and deterministic; CI/Kaggle friendly.

==============================================================================

version: 2
enabled: true

——————————————————————————

CDS strategy

——————————————————————————

cds:

mode: “reset_signal” | “frame_diff” | “rolling_window” | “odd_even” | “reference_frame” | “auto”

- “auto” chooses “reset_signal” if reset flag metadata present, else “frame_diff”.

mode: “frame_diff”

————————

PAIRING RULES

————————

pairing:
# Only used when mode in {“reset_signal”,“frame_diff”,“odd_even”}.
# policy: “n_minus_1” | “nearest” | “time_window” | “even_odd”
#  - n_minus_1   : pair frame n with n-1 (classic sequential CDS)
#  - nearest     : pair frame n with nearest candidate by time/index
#  - time_window : pair n with a candidate within +/- window_s (fails if none)
#  - even_odd    : pair odd with preceding even (or vice versa)
policy: “n_minus_1”

# Choose the domain that defines ordering:
# "index" uses monotonically increasing frame indices
# "timestamp" uses acquisition times from metadata
order_by: "index"                     # "index" | "timestamp"

# Metadata keys (only used if order_by == "timestamp")
timestamp_key: "acq_timestamp_s"      # seconds (float)
# Frame index key (optional; used for logging even if order_by==timestamp)
index_key: "frame_index"

# Time window (seconds) when policy == "time_window" or "nearest"
window_s: 5.0

# When policy == "even_odd", control the subtraction direction:
even_odd:
  # "odd_minus_even" or "even_minus_odd"
  direction: "odd_minus_even"

# When mode == "reset_signal", identify RESET vs SIGNAL frames
reset_signal:
  reset_flag_key: "is_reset"          # boolean in metadata
  # If true, (signal - reset). If false, (reset - signal)
  subtract_signal_minus_reset: true
  # Require a reset within window_s preceding the signal (else warn/error)
  require_temporal_proximity: true

# Drop unpaired frames or keep (filled with zeros) — only for diagnostics;
# kept frames are flagged and excluded downstream by QC.
keep_unpaired_for_diagnostics: false

————————

REFERENCE FRAME (mode = “reference_frame”)

————————

reference_frame:
# Strategy: “static” path or “running” (compute from neighbors)
strategy: “static”                     # “static” | “running”
static:
path: “${oc.env:DATA_DIR, data}/calib/cds/reference_frame.npy”  # (H,W) or (C,H,W)
running:
half_window: 3                       # median/mean of neighbors (excl. center)
exclude_center: true
baseline: “median”                   # “median” | “mean”
robust:
enabled: true
sigma_clip: 3.0
max_iters: 2

————————

ROLLING-WINDOW BASELINE (mode = “rolling_window”)

————————

rolling_window:
baseline: “median”                     # “median” | “mean”
half_window: 3                         # window on each side; size = 2*half_window + 1
exclude_center: true
robust:
enabled: true
sigma_clip: 3.0
max_iters: 3

————————

ROBUST DIFFERENCING & OUTLIER TREATMENT

————————

robust:
# Clip pair residuals before write-out (helps suppress CRs in differenced frames)
sigma_clip:
enabled: true
sigma: 10.0
max_iters: 1
# Replace extreme outliers after CDS with local spatial median
outlier_replace:
enabled: true
threshold_sigma: 12.0
mode: “median4”                     # “median4” | “median8” | “gaussian3”
max_replace_fraction: 0.03

————————

TEMPORAL CLEANUP (optional)

————————

temporal_filter:
enabled: false
# kind: “highpass” | “bandpass”
kind: “highpass”
# For highpass: cutoff as fraction of Nyquist in (0,1)
highpass_cutoff: 0.05
# For bandpass: [low, high] fractions of Nyquist
bandpass_range: [0.02, 0.30]
# Apply per-pixel along time using a zero-phase IIR/FIR (implementation-dependent)
zero_phase: true
# Light cosine taper to reduce edge artifacts (0..0.2)
taper_frac: 0.05

————————

COMMON-MODE / SCALE NORMALIZATION (optional)

————————

normalization:
enabled: true
# method: “none” | “mad” | “global_median” | “per_channel_median”
method: “none”
per_channel: false                    # if true and C>1, normalize each channel separately
eps: 1.0e-8

——————————————————————————

NOISE MODEL (for diagnostics/quality checks; does not change pixel values)

——————————————————————————

noise_model:
enabled: true

Read noise per read (ADU). Expected CDS variance for differenced pairs:

var_cds ≈ var(read1) + var(read2) (assuming independence).

read_noise_adu: 5.0

Optional shot noise estimate if conversion gain is known

shot_noise:
enabled: false
conversion_gain_e_per_adu: 1.0

Optional per-channel gain map for AIRS to convert ADU→e⁻ in diagnostics

gain_map_path: null                   # “${oc.env:DATA_DIR, data}/calib/gain_map.npy”

——————————————————————————

Quality checks (soft guards; do not mutate data)

——————————————————————————

quality_checks:
enabled: true

pairing_integrity:
# Max fraction of frames allowed to be unpaired (or missing reset) before warn/error
max_unpaired_fraction: 0.10
# Monotonicity checks when order_by == “timestamp”
require_monotonic_timestamps: true
max_time_gap_s: null               # warn if a gap exceeds this (null to disable)

post_cds_stats:
sampling_fraction: 0.10
min_samples: 2
# Expect near-zero mean (CDS removes DC); allow margin for transients
mean_adu_range: [-1000.0, 1000.0]
# Expect reasonable spread (not degenerate, not exploded)
std_adu_range: [0.1, 30000.0]

histogram_after:
bins: 256
# Too-large zero pile-up may indicate over-aggressive clipping or dead frames
max_at_zero_frac: 0.25

Cross-channel coherence for AIRS (median absolute deviation of per-channel means)

cross_channel:
enabled: true
mad_of_means_max: 0.50

action_on_fail: “warn”               # “warn” | “error”

——————————————————————————

I/O routing for pipeline memory dict

——————————————————————————

io:
input_key: “flat_corrected”
output_key: “cds_corrected”

Optional extra outputs (saved only if diagnostics.enabled)

extra_outputs:
pair_index_key: “cds_pair_index”        # (B,) index of paired frame used (or -1 if none)
pair_delta_t_key: “cds_pair_dt_s”       # (B,) time delta used for pairing
baseline_key: “cds_baseline_used”       # used baseline (rolling/reference)

——————————————————————————

Caching & DVC

——————————————————————————

cache:
write_intermediate: true
out_dir: “${oc.env:RUN_DIR, runs}/calib/cds”
dvc_stage_name: “calib_cds”
cache_key:
mode: “${cds.mode}”
policy: “${cds.pairing.policy}”

——————————————————————————

Logging & diagnostics

——————————————————————————

logging:
level: “INFO”                         # “DEBUG” | “INFO” | “WARNING” | “ERROR”
log_sample_stats: true                # per-batch stats before/after CDS
save_debug_images: false              # save grids of paired frames & CDS outputs
diagnostics:
enabled: false
outdir: “outputs/diagnostics/calib_cds”
sample_indices:
frames: []                        # e.g., [0, 128, 256]
channels: []                      # e.g., [0, 50, 120]
export_stats_csv: false

——————————————————————————

Runtime

——————————————————————————

runtime:
num_workers: 2
seed: 1337
per_frame_budget_ms: 50               # soft guardrail per frame (tune to runtime)

——————————————————————————

Validation — fail fast for missing metadata or impossible pairing

——————————————————————————

validation:

When pairing requires metadata (timestamps, reset flags), enforce presence

require_metadata_keys:
timestamp: [“acq_timestamp_s”]
index: [“frame_index”]
reset_signal: [“is_reset”]

If the chosen policy/mode depends on these keys, they must exist. Otherwise ignored.

require_existing_paths: false
check_shape_compatibility: true

If mode == “auto”, ensure selection is sane (prefer reset_signal when reset flag present)

require_auto_logic_sanity: true

Ensure finite inputs before differencing

require_finite_inputs: true