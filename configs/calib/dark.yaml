FILE: configs/calib/dark.yaml

==============================================================================

DARK FRAME SUBTRACTION — SpectraMind V50 Calibration Kill Chain (stage 02, upgraded)

——————————————————————————

Purpose

Remove sensor dark signal (bias-independent thermal current + fixed patterns)

from ADC-corrected frames. Supports master darks, per-pixel current maps,

exposure-time & temperature scaling, unit conversion, and hot/bad-pixel cleanup.



Contract

In : io.input_key   (typically produced by configs/calib/adc.yaml)

Out: io.output_key  (consumed by flat/cds/photometry stages)



Notes

• Paths are DVC-friendly; use ${oc.env:DATA_DIR, data} as the root for artifacts.

• Numerically safe (eps floors, NaN/Inf handling), deterministic, CI/Kaggle-ready.

• If a required file is missing, behavior follows validation.require_existing_paths.

==============================================================================

version: 2
enabled: true

——————————————————————————

Dark subtraction model

——————————————————————————

dark_model:

method: “none” | “master” | “per_pixel_map” | “auto”

- “master”        : subtract a master dark frame (optionally scaled)

- “per_pixel_map” : compute dark from a per-pixel current map (rate × exposure)

- “auto”          : choose per_pixel_map if map is present, else master (if present), else none

method: “master”

————————

MASTER DARK SETTINGS

————————

master:
# Reference master dark aligned with detector geometry:
#   NPY (H×W) or (C×H×W). If C>1 and the cube has channels, the C dimension must match
#   unless a channel remap is supplied by the pipeline.
path: “${oc.env:DATA_DIR, data}/calib/dark/master_dark.npy”

# Optional exposure-time scaling for master darks.
# If the master encodes a *rate* (per second), scale_exposure=true with ref_exposure_s
# set to the master build exposure. If the master encodes an *accumulated* dark
# for a specific exposure, keep scale_exposure=false.
scale_exposure: false
ref_exposure_s: 1.0
exposure_key: "exposure_time_s"       # meta key used to fetch per-frame exposure

# Optional temperature scaling (linear or Arrhenius-like approximation).
temperature:
  enabled: false
  # method: "linear" | "arrhenius"
  method: "linear"
  # For linear: dark(T) = dark(Tr) * [1 + slope_per_K * (T - Tr)]
  slope_per_K: 0.10
  ref_temp_K: 293.15                  # ~20°C
  # For arrhenius: dark ∝ exp(-Ea / (k * T)); provide activation energy (eV)
  activation_energy_eV: 0.60
  # Pull T from metadata; if missing, fall back to ref_temp_K
  temp_key: "detector_temperature_K"

# Optional unit conversion if master is in electrons but frames are ADU (or vice versa).
convert_units:
  enabled: false
  # "e_to_adu" or "adu_to_e"
  direction: "e_to_adu"
  conversion_gain_e_per_adu: 1.0

# Optional bias pedestal removal if master includes a constant offset (rare).
remove_pedestal:
  enabled: false
  value_adu: 0.0

————————

PER-PIXEL MAP SETTINGS

————————

per_pixel_map:
# Dark current map path:
#   If units == “e_per_s”   : map is electrons per second (H×W or C×H×W)
#   If units == “adu_per_s” : map is ADU per second   (same shapes)
map_path: “${oc.env:DATA_DIR, data}/calib/dark/dark_current_map.npy”
units: “e_per_s”                      # “e_per_s” | “adu_per_s”

# Exposure/temperature scaling (applied to rate to get accumulated dark).
scale_exposure: true
exposure_key: "exposure_time_s"

temperature:
  enabled: false
  method: "linear"                    # "linear" | "arrhenius"
  slope_per_K: 0.10
  ref_temp_K: 293.15
  activation_energy_eV: 0.60
  temp_key: "detector_temperature_K"

# If units == e_per_s but frames are ADU, convert using gain.
convert_units:
  enabled: true
  direction: "e_to_adu"
  conversion_gain_e_per_adu: 1.0

# Optional channel remap when C differs between map and data (provided by pipeline).
channel_remap: null                   # e.g., [0,2,1,...] to permute; null to disable

————————

COMMON OPTIONS

————————

Optional per-frame DC pedestal subtraction (post scaling, pre subtraction).

Useful if upstream ADC leaves a small constant bias.

pedestal:
enabled: false
# Estimate pedestal via robust median of a background ROI (ignores sources if mask provided).
estimate:
use_robust_median: true
roi: null                           # [y0,y1,x0,x1] or null for full-frame
valid_mask_key: null                # key to a (H×W) mask in memory dict (1=valid)
# Or provide a fixed value (overrides estimate if not null)
fixed_value_adu: null

After subtracting the dark, optionally clamp small negatives to avoid

propagating unphysical values into flat/CDS. Keep a small margin to preserve noise.

post_subtraction_clamp:
enabled: true
min_adu: -5.0

Numerical safety

safety:
epsilon: 1.0e-8                       # avoid divide-by-zero in conversions
handle_invalid: true                  # replace NaN/Inf after subtraction
fill:
method: “median3”                   # “median3” | “nearest” | “zero”

——————————————————————————

Bad / hot pixel handling (applied AFTER subtraction)

——————————————————————————

bad_pixel_handling:
enabled: true

Provide a static bad-pixel map (1 = bad, 0 = good).

bpm_path: “${oc.env:DATA_DIR, data}/calib/masks/bad_pixel_map.npy”

Identify additional hot pixels dynamically by sigma threshold on residuals.

hot_pixel_detection:
enabled: true
sigma_threshold: 8.0
min_value_adu: 200.0                  # only consider pixels above this absolute value
dilate_radius_px: 0                   # set >0 to expand detections morphologically

Replacement policy for bad + detected hot pixels.

replace:
mode: “median4”                       # “median4” | “median8” | “gaussian3”
# Guard against replacing too many pixels in a small area; acts as a sanity cap.
max_replace_fraction: 0.05

——————————————————————————

Optional cosmic-ray removal (simple L.A.Cosmic-style gate; conservative defaults)

——————————————————————————

cosmic_rays:
enabled: false
sigma_threshold: 10.0
grow_radius_px: 1
replace_mode: “median8”                 # reuse bad-pixel replacement modes

——————————————————————————

Diagnostics (optional artifacts)

——————————————————————————

diagnostics:
enabled: false
outdir: “outputs/diagnostics/calib_dark”
save_debug_images: false                # small grids of before/after & residuals
sample_indices:
frames: []                            # e.g., [0, 128, 256]
channels: []                          # e.g., [0, 50, 120]
export_stats_csv: false

——————————————————————————

Quality checks (soft guards; do not mutate data)

——————————————————————————

quality_checks:
enabled: true

Check a small random subset of frames for residual statistics.

sampling:
fraction: 0.10
min_samples: 2

Expect the residual mean ~0 after dark removal; std within plausible bounds.

residual_stats:
mean_adu_range: [-200.0, 200.0]
std_adu_min: 1.0
std_adu_max: 30000.0

Fraction at exact clamp boundary (if clamp enabled); too high => over-clamping.

residual_histogram:
bins: 256
max_at_clamp_frac: 0.10

Cross-channel coherence check for AIRS (median of per-channel residual means)

cross_channel:
enabled: true
mad_of_means_max: 250.0

“warn” (log + continue) or “error” (raise)

action_on_fail: “warn”

——————————————————————————

I/O routing for pipeline memory dict

——————————————————————————

io:
input_key: “adc_corrected”              # produced by ADC stage
output_key: “dark_corrected”            # consumed by flat/CDS/photometry

Optional extra outputs (saved only if diagnostics.enabled)

extra_outputs:
dark_applied_key: “dark_frame_applied”    # the dark image actually subtracted

——————————————————————————

Caching & DVC hooks

——————————————————————————

cache:
write_intermediate: true
out_dir: “${oc.env:RUN_DIR, runs}/calib/dark”
dvc_stage_name: “calib_dark”
cache_key:
method: “${dark_model.method}”

——————————————————————————

Logging & runtime

——————————————————————————

logging:
level: “INFO”                         # “DEBUG” | “INFO” | “WARNING” | “ERROR”
log_sample_stats: true
save_debug_images: false

runtime:
num_workers: 2
seed: 1337
per_frame_budget_ms: 50               # soft guardrail; tune per runtime

——————————————————————————

Validation — fail fast if required resources are missing or incompatible

——————————————————————————

validation:
require_existing_paths: true          # if method uses files, they must exist
check_shape_compatibility: true       # ensure master/map shapes line up with first batch

At least one scaling dimension must be resolvable when enabled (exposure/temperature).

require_metadata_keys:
exposure: [“exposure_time_s”]
temperature: [“detector_temperature_K”]

If method == “auto”, ensure availability logic is sane (prefers per-pixel map if present).

require_auto_logic_sanity: true

Ensure finite inputs before subtraction

require_finite_inputs: true