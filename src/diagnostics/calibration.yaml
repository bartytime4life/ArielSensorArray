# configs/diagnostics/calibration.yaml

# ==============================================================================

# ðŸŽ¯ Uncertainty Calibration Diagnostics

# SpectraMind V50 â€” NeurIPS 2025 Ariel Data Challenge

# ------------------------------------------------------------------------------

# Purpose:

# Evaluate predicted uncertainties (Ïƒ) against residuals (|Î¼ - y|).

# Includes reliability diagrams, quantile coverage, z-score histograms,

# molecule-region calibration, per-split/per-planet summaries, and COREL hooks.

#

# Hydra:

# Hydra-safe; override via CLI, e.g.:

# spectramind diagnose calibration \\

# calibration.coverage.quantiles="\[0.05,0.5,0.95]" \\

# calibration.temp\_scale.enable=true

#

# Outputs:

# â€¢ Calibration plots (PNG/HTML)

# â€¢ Coverage CSV/JSON summaries (per-bin / per-molecule / per-split / per-planet)

# â€¢ Bootstrap CIs & statistical tests (optional)

# â€¢ Reproducibility logs with config hash and manifest

#

# Conventions:

# â€¢ Paths interpolate `${paths.*}` from configs/paths.yaml

# â€¢ Read-only diagnostics: never mutates Î¼/Ïƒ/y unless temp\_scale/per\_bin\_scale enabled

# â€¢ HTML/plots default under `${paths.artifacts}` for dashboard bundling

# ==============================================================================

# ------------------------------------------------------------------------------

# Hydra defaults

# ------------------------------------------------------------------------------

defaults:

* override hydra/job\_logging: default
* override hydra/hydra\_logging: default

# ------------------------------------------------------------------------------

# Master block

# ------------------------------------------------------------------------------

calibration:
enable: true

# ------------------------------------------------------------------

# Inputs & data filters

# ------------------------------------------------------------------

inputs:
mu\_path: "\${paths.artifacts}/predict/mu.npy"              # \[N\_planets, 283]
sigma\_path: "\${paths.artifacts}/predict/sigma.npy"        # same shape as Î¼
y\_path: "\${paths.artifacts}/labels/y.npy"                 # ground truth (if available)
meta\_csv: "\${paths.artifacts}/predict/meta.csv"           # planet\_id, split, molecules, etc.
mask\_path: null                                           # optional mask for valid bins (1=valid)
bin\_weight\_path: null                                     # optional length-283 weights (SNR/coverage)
filter:
include\_splits: \["train", "val", "test"]
exclude\_planets: \[]                                       # explicit planet\_ids to drop
valid\_sigma\_range: \[1.0e-6, null]                         # clamp Ïƒ to this range before eval
min\_bins\_for\_eval: 50                                     # skip planet if valid bins < this
drop\_nan\_rows: true

# ------------------------------------------------------------------

# Coverage analysis (empirical vs nominal)

# ------------------------------------------------------------------

coverage:
quantiles: \[0.1, 0.2, 0.5, 0.8, 0.9]                      # target nominal coverages
per\_bin: true                                             # per spectral bin evaluation
per\_molecule\_region: true                                 # group bins by molecule bands
per\_split: true                                           # report per dataset split
per\_planet: true                                          # planet-level coverage table
per\_cluster: false                                        # enable if meta has 'cluster'
temporal\_slices: false                                    # vs transit phase if meta has 'phase'
stratify\_by:
\- "snr\_bucket"                                          # optional columns in meta.csv
\- "molecule\_region"
weighted: true                                            # use bin\_weight\_path/SNR if available
bootstrap:
enable: true
n\_resamples: 500
ci: 0.95                                                # two-sided CI for coverage estimates
seed: 1337
pit:
enable: true                                            # Probability Integral Transform diagnostic
ks\_test: true                                           # Kolmogorovâ€“Smirnov vs U(0,1)
qq\_plot: true

# ------------------------------------------------------------------

# Reliability diagrams (Expected/Maximum Calibration Error)

# ------------------------------------------------------------------

reliability:
n\_bins: 15
binning: "equal\_mass"                                     # equal\_mass | equal\_width
min\_count\_per\_bin: 25
compute\_ece: true                                         # Expected Calibration Error
compute\_mce: true                                         # Maximum Calibration Error
ece\_norm: "l1"                                            # l1 | l2 | sqrt
per\_split: true
per\_molecule\_region: true
weighted: true                                            # weight by precision/SNR if available
show\_confidence\_bands: true                               # bootstrap CIs on diagram

# ------------------------------------------------------------------

# Z-score evaluation

# ------------------------------------------------------------------

zscore:
enable: true
clip: 6.0                                                 # clip extreme z-scores
per\_bin: true
per\_molecule\_region: true
per\_split: true
histogram\_bins: 41
normality\_tests:
enable: true
tests: \["shapiro", "anderson", "dagostino"]             # run on aggregated z by group
alpha: 0.01
qq\_plot: true

# ------------------------------------------------------------------

# Temperature scaling & per-bin scaling hooks (post-hoc)

# (Applied in-memory for evaluation preview; optionally exported)

# ------------------------------------------------------------------

temp\_scale:
enable: false
mode: "global"                                            # global | per\_bin | per\_molecule
optimizer: "lbfgs"                                        # lbfgs | adam
max\_iter: 200
tol: 1.0e-6
init: 1.0
bounds: \[0.05, 20.0]
export\_json: "\${paths.artifacts}/calibration/temp\_scale.json"
per\_bin\_scale:
enable: false
l2\_reg: 1.0e-3                                            # discourage overfit
bounds: \[0.05, 20.0]
export\_json: "\${paths.artifacts}/calibration/per\_bin\_scale.json"

# ------------------------------------------------------------------

# COREL calibration integration (binwise conformal prediction)

# ------------------------------------------------------------------

corel:
enable: true
evaluate\_coverage: true
alpha: 0.1                                                # 1 - desired marginal coverage
use\_graph\_edges: true                                     # spectral/molecule adjacency
use\_positional\_encoding: false
export\_heatmap: true
heatmap\_png: "\${paths.artifacts}/calibration/corel\_heatmap.png"
summary\_csv: "\${paths.artifacts}/calibration/corel\_summary.csv"
coverage\_json: "\${paths.artifacts}/calibration/corel\_coverage.json"

# ------------------------------------------------------------------

# Symbolic overlays (read-only fusion into plots/tables)

# ------------------------------------------------------------------

overlays:
symbolic\_mask\_npy: "\${paths.artifacts}/symbolic/violations\_mask.npy"    # \[N, 283] (1=violation)
highlight\_symbolic\_regions: true
annotate\_fail\_bands: true

# ------------------------------------------------------------------

# Plotting options

# ------------------------------------------------------------------

plots:
reliability\_diagram: true
reliability\_per\_split: true
z\_histogram: true
z\_qq\_plot: true
pit\_histogram: true
per\_bin\_coverage: true
molecule\_region\_coverage: true
coverage\_violin\_by\_split: true
save\_png: true
save\_html: true
html\_interactive: true
dpi: 160
figsize: \[9, 6]
out\_dir: "\${paths.artifacts}/calibration"
theme:
background: "white"                                   # white | dark
palette: "astro"                                      # astro | colorblind\_safe | grayscale
cmap: "viridis"

# ------------------------------------------------------------------

# Export artifacts

# ------------------------------------------------------------------

export:
base\_dir: "\${paths.artifacts}/calibration"
coverage\_csv: "\${calibration.export.base\_dir}/coverage.csv"             # wide groupsÃ—quantiles
coverage\_json: "\${calibration.export.base\_dir}/coverage.json"
per\_split\_csv: "\${calibration.export.base\_dir}/coverage\_by\_split.csv"
per\_planet\_csv: "\${calibration.export.base\_dir}/coverage\_by\_planet.csv"
per\_bin\_csv: "\${calibration.export.base\_dir}/per\_bin.csv"
molecule\_csv: "\${calibration.export.base\_dir}/molecule\_region.csv"
reliability\_png: "\${calibration.export.base\_dir}/reliability.png"
reliability\_split\_png: "\${calibration.export.base\_dir}/reliability\_by\_split.png"
reliability\_html: "\${calibration.export.base\_dir}/reliability.html"
z\_hist\_png: "\${calibration.export.base\_dir}/z\_hist.png"
z\_qq\_png: "\${calibration.export.base\_dir}/z\_qq.png"
pit\_png: "\${calibration.export.base\_dir}/pit\_hist.png"
violin\_split\_png: "\${calibration.export.base\_dir}/coverage\_violin\_by\_split.png"
summary\_json: "\${calibration.export.base\_dir}/summary.json"             # roll-up metrics + ECE/MCE
events\_jsonl: "\${calibration.export.base\_dir}/events.jsonl"             # stepwise logging for CI

# ------------------------------------------------------------------

# Reproducibility & logging

# ------------------------------------------------------------------

reproducibility:
log\_hash: true                                                        # record config hash to v50\_debug\_log.md
snapshot\_config: true                                                 # save calibration.yaml snapshot with results
run\_manifest: "\${calibration.export.base\_dir}/manifest.json"
record\_cli\_invocation: true
record\_env: true                                                      # python/packages/cuda versions
append\_v50\_debug\_log: "\${paths.logs}/v50\_debug\_log.md"

# ------------------------------------------------------------------

# Performance hints & caching

# ------------------------------------------------------------------

cache:
enable: true
dir: "\${paths.cache}/calibration"
reuse\_if\_hash\_matches: true
parallel:
workers: 8                                                            # for groupwise computations / bootstraps
backend: "thread"                                                     # thread | process
perf:
device: "auto"                                                        # auto | cpu | cuda:0 | mps
dtype: "float32"
chunk\_size\_planets: 256

# ------------------------------------------------------------------

# Failure policy

# ------------------------------------------------------------------

policy:
fail\_on\_missing\_labels: false                                         # allow unlabeled sets; skip dependent evals
warn\_on\_small\_groups: true                                            # warn if group size < min\_count\_per\_bin
continue\_on\_plot\_errors: true                                         # still export CSVs if plotting fails

# ------------------------------------------------------------------

# Report & dashboard integration

# ------------------------------------------------------------------

report:
include\_in\_html\_report: true
open\_in\_browser: false
section\_key: "calibration"

# ------------------------------------------------------------------

# CI/QA hooks

# ------------------------------------------------------------------

ci:
require\_exports: true
require\_plots: true
max\_html\_size\_mb: 40
sanity:
max\_nan\_fraction: 0.001
max\_empty\_rows\_fraction: 0.10
warn\_if\_ece\_worse\_than: 0.15
warn\_if\_mce\_worse\_than: 0.45

# ------------------------------------------------------------------

# Cross-module bindings (discoverability for other tools)

# ------------------------------------------------------------------

bindings:
diagnostic\_summary\_json: "\${paths.artifacts}/diagnostics/diagnostic\_summary.json"
symbolic\_rule\_rank\_json: "\${paths.artifacts}/symbolic/rule\_rank.json"
gll\_summary\_json: "\${paths.artifacts}/diagnostics/gll\_summary.json"
