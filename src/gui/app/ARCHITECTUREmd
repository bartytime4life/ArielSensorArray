# 🧭 SpectraMind V50 — GUI Architecture

## 0) Purpose

The GUI is a **thin, optional visualization layer** over the **CLI-first** SpectraMind V50 pipeline.  
It never computes analytics itself; it **renders CLI-produced artifacts** and **calls server APIs** that orchestrate the CLI, preserving **NASA-grade reproducibility** (Hydra configs, DVC data/model hashes, run logs):contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}.

---

## 1) High-Level Architecture

```mermaid
flowchart LR
  subgraph Client (React/Vite)
    R[Routes: /diagnostics, /reports]
    S[State: run meta, filters]
    V[Views: tables, charts, iframes]
  end

  subgraph Server (FastAPI)
    A[/api/diagnostics/*/]:::api
    M[/api/authz/*/]:::api
    X[(Static /artifacts)]:::static
  end

  subgraph CLI & Pipeline
    C[spectramind diagnose dashboard]:::cli
    H[(Hydra configs)]:::cfg
    D[(DVC data/models)]:::cfg
    L[v50_debug_log.md]:::log
  end

  R --> A
  V --> X
  A --> C
  C --> X
  C --> L
  C --> H
  C --> D

  classDef api fill:#e8f4ff,stroke:#2a7bd3,color:#0b4080;
  classDef static fill:#f9f7e8,stroke:#bb9b0b,color:#6e5800;
  classDef cli fill:#f3e8ff,stroke:#7f3fbf,color:#3e1f63;
  classDef cfg fill:#eefaf0,stroke:#2f9e44,color:#125c2b;
  classDef log fill:#fbe9e9,stroke:#c73636,color:#5a1c1c;
````

**Key properties**

* **CLI-first:** all heavy work is delegated to `spectramind …`; the GUI only triggers/reads results
* **Reproducible:** every run is tied to Hydra config snapshots and DVC-tracked artifacts
* **Air-gapped friendly:** no third-party services are required; header-auth is local and file/env configurable

---

## 2) Routing & Views

* **`/diagnostics`** — fetches `GET /api/diagnostics/summary`, lists recent artifacts (png/html/json), and links/embeds content under `/artifacts/*`.
  It may POST `/api/diagnostics/run` to trigger `spectramind diagnose dashboard` **without** performing analytics in the browser.
* **`/reports`** — browses static HTML reports (e.g., `diagnostic_report_v*.html`) and other CLI outputs published to `/artifacts/*`.

> The GUI explicitly **does not** bypass the CLI/Hydra/DVC flow; it merely reflects pipeline outputs for audits and exploration.

---

## 3) Data Flow

```mermaid
sequenceDiagram
  participant User
  participant GUI as GUI (React)
  participant API as FastAPI /api/diagnostics
  participant CLI as spectramind
  participant FS as /artifacts & logs

  User->>GUI: Open /diagnostics
  GUI->>API: GET /summary
  API-->>GUI: diagnostic_summary.json
  GUI->>API: (optional) POST /run
  API->>CLI: invoke diagnose dashboard
  CLI->>FS: write html/png/json + v50_debug_log.md
  GUI->>FS: load /artifacts/umap.html, plots…
```

* **Inputs:** summary JSON from the Diagnostics API; static HTML/PNG under `/artifacts/`
* **Outputs:** none (GUI does not write artifacts); all outputs are produced by the CLI and logged with run hashes for traceability.

---

## 4) State Management

* **Local, view-scoped state only** (filters, sort order, open panels).
* **No derived computation** (e.g., SHAP/FFT) is done in the browser; those are consumed as ready-to-render artifacts or JSON produced by the pipeline.

---

## 5) Security & Authorization

* **Header-based auth**: `X-API-Key` or `Authorization: Bearer …` (if enabled) with a simple local RBAC policy (users/roles/scopes) managed by environment or a YAML/JSON policy file.
* **Scopes:** endpoints can require `diagnostics:read` / `diagnostics:run`; GUI forwards credentials only, never stores secrets in code.
* **No direct file writes:** GUI reads `/artifacts/*` via the server’s static mount; upload/mutation is out of scope, preserving immutability of artifacts.

---

## 6) Performance & UX Notes

* **Static-first rendering:** where possible, load prebuilt HTML/plots to minimize client CPU.
* **Avoid long-running requests:** dispatch `POST /api/diagnostics/run` and **reflect status via follow-up GETs**; do not poll aggressively.
* **Lightweight stack:** React + Vite + Tailwind + shadcn/ui; no heavyweight charting unless artifacts require it.

---

## 7) Build & Deploy

* **Dev:** `npm run dev` (Vite).
* **Prod:** `npm run build` → static assets served by the same FastAPI instance or a static file server in front of `/api`.
* **Server contract:** FastAPI exposes `/api/diagnostics/*` and mounts `/artifacts` directory; CLI writes artifacts under that mount path.

---

## 8) Reproducibility & Auditability

* **Hydra:** every CLI run records the composed config & version/hash, which the GUI can display/link (e.g., “config.yaml” next to each report).
* **DVC:** raw/calibrated data & model checkpoints are versioned; GUI renders whatever the current run produced without mutating lineage.
* **Logs:** `v50_debug_log.md` provides run history; GUI links to tails or summarizes recent events.

---

## 9) Diagramming in Docs

All diagrams in this architecture are **Mermaid** blocks rendered by GitHub automatically in Markdown.
To keep README/architecture docs current, prefer Mermaid to static images.

Example:

```mermaid
flowchart LR
  A[GUI] -->|GET /summary| B(API)
  B --> C[(Artifacts)]
```

---

## 10) Non-Goals

* No model training/inference in the browser.
* No “ad-hoc” computation paths that diverge from CLI.
* No persistence of secrets or writable artifact stores in the GUI app.

---

## 11) Why this design?

* **CLI-first** ensures that **every** result is tied to an auditable, versioned config and data snapshot, which is critical for scientific credibility and competition settings (e.g., Kaggle).
* A thin GUI **reduces drift** between “what the code did” and “what the user saw,” since both consume the same artifacts and logs produced by the pipeline.

---

```
```
