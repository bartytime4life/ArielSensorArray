upgrade, # ==============================================================================

# SpectraMind V50 — PR Auto Labeler (paths ✦ title ✦ size ✦ guardrails)

# - Path labels via actions/labeler using .github/labeler.yml (kept in target repo)

# - Title labels via Conventional Commits (feat/fix/docs/chore/refactor/test/build/ci/perf/style/revert)

# - Breaking-change detection via "!" or "BREAKING CHANGE"

# - Size labels (XS/S/M/L/XL) computed from exact PR diff (additions+deletions), with ignore globs

# - WIP/draft detection → adds "status\:wip"

# - Fork-safe (pull\_request\_target), minimal perms, concurrency keyed to PR\#

# ==============================================================================

name: PR Auto Labeler

on:
pull\_request\_target:
types:
\- opened
\- synchronize
\- reopened
\- edited
\- ready\_for\_review
\- unlocked
\- converted\_to\_draft

permissions:
contents: read
pull-requests: write

concurrency:
group: pr-labeler-\${{ github.event.pull\_request.number || github.run\_id }}
cancel-in-progress: false

env:

# Glob patterns to ignore when computing "size/\*" (newline or comma-separated)

SIZE\_IGNORE\_GLOBS: |
**/*.lock
\*\*/poetry.lock
\*\*/package-lock.json
\*\*/pnpm-lock.yaml
\*\*/yarn.lock
**/dist/**
**/build/**
**/.vite/**
**/.next/**
**/site/**
**/.dvc/tmp/**
\*\*/*.ipynb\_checkpoints/**
**/.generated/**
\*\*/*.min.js
\*\*/*.min.css
**/vendor/**
\*\*/.github/labeler.yml

jobs:
guard:
name: Guard / Skip heuristics
runs-on: ubuntu-latest
outputs:
skip: \${{ steps.check.outputs.skip }}
steps:
\- id: check
uses: actions/github-script\@v7
with:
script: |
const pr = context.payload.pull\_request;
let skip = false;
if (!pr) skip = true;
const title = (pr?.title || '').toLowerCase();
const labels = (pr?.labels || \[]).map(l => (l.name || '').toLowerCase());
// Skip if marked as draft/WIP or explicit skip label/marker
if (pr?.draft) skip = true;
if (title.includes('\[skip labeler]') || title.includes('\[label\:skip]')) skip = true;
if (labels.includes('skip-labeler')) skip = true;
core.setOutput('skip', skip ? 'true' : 'false');

paths:
name: Path-based labels
needs: guard
if: needs.guard.outputs.skip != 'true'
runs-on: ubuntu-latest
steps:
\- name: Apply labels from changed files (.github/labeler.yml)
uses: actions/labeler\@v5
with:
repo-token: \${{ secrets.GITHUB\_TOKEN }}
configuration-path: .github/labeler.yml
sync-labels: true

title:
name: Title-based labels (Conventional Commits)
needs: guard
if: needs.guard.outputs.skip != 'true'
runs-on: ubuntu-latest
steps:
\- name: Label by PR title
uses: actions/github-script\@v7
with:
script: |
const pr = context.payload.pull\_request;
if (!pr) return;

```
        const title = pr.title || "";
        const add = new Set();
        const del = new Set();

        // Map Conventional Commit type → label(s)
        const rules = [
          { re: /^feat(\(.+\))?!?:/i,     labels: ['type:feature'] },
          { re: /^fix(\(.+\))?!?:/i,      labels: ['type:bug'] },
          { re: /^docs(\(.+\))?!?:/i,     labels: ['type:docs'] },
          { re: /^chore(\(.+\))?!?:/i,    labels: ['type:chore'] },
          { re: /^refactor(\(.+\))?!?:/i, labels: ['type:refactor'] },
          { re: /^test(\(.+\))?!?:/i,     labels: ['type:test'] },
          { re: /^build(\(.+\))?!?:/i,    labels: ['type:build'] },
          { re: /^ci(\(.+\))?!?:/i,       labels: ['type:ci'] },
          { re: /^perf(\(.+\))?!?:/i,     labels: ['type:perf'] },
          { re: /^style(\(.+\))?!?:/i,    labels: ['type:style'] },
          { re: /^revert(\(.+\))?!?:/i,   labels: ['type:revert'] },
        ];

        for (const r of rules) {
          if (r.re.test(title)) r.labels.forEach(l => add.add(l));
        }

        // Breaking change signal
        if (/!:/ .test(title) || /\bBREAKING CHANGE\b/i.test(title)) {
          add.add('breaking-change');
        }

        // WIP/Draft
        if (pr.draft || /\bWIP\b/i.test(title) || /\bDO NOT MERGE\b/i.test(title)) {
          add.add('status:wip');
        }

        // Clean up existing type:* to keep only desired set
        const { data: existing } = await github.rest.issues.listLabelsOnIssue({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: pr.number,
        });
        const existingTypes = existing.filter(l => l.name.startsWith('type:')).map(l => l.name);
        existingTypes.forEach(l => del.add(l));
        // Keep the ones we're adding
        for (const l of add) del.delete(l);

        if (del.size) {
          await github.rest.issues.removeLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr.number,
            labels: Array.from(del),
          }).catch(() => {});
        }
        if (add.size) {
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr.number,
            labels: Array.from(add),
          });
        }
```

size:
name: Size labels (XS/S/M/L/XL)
needs: guard
if: needs.guard.outputs.skip != 'true'
runs-on: ubuntu-latest
steps:
\- name: Compute & apply size label (exact diff, with ignore globs)
uses: actions/github-script\@v7
with:
script: |
const micromatch = require('micromatch');
const pr = context.payload.pull\_request;
if (!pr) return;

```
        // Pull all changed files for this PR (paginate)
        let files = [];
        let page = 1;
        while (true) {
          const { data } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: pr.number,
            per_page: 100,
            page
          });
          files = files.concat(data);
          if (data.length < 100) break;
          page += 1;
        }

        // Build ignore patterns
        const raw = process.env.SIZE_IGNORE_GLOBS || '';
        const patterns = raw.split(/\r?\n|,/).map(s => s.trim()).filter(Boolean);

        // Sum additions+deletions ignoring matches
        let changed = 0;
        for (const f of files) {
          const path = f.filename || '';
          if (patterns.length && micromatch.isMatch(path, patterns)) continue;
          changed += (f.additions || 0) + (f.deletions || 0);
        }

        // Thresholds
        const thresholds = [
          { label: 'size/XS', max:   49 },
          { label: 'size/S',  max:  199 },
          { label: 'size/M',  max:  499 },
          { label: 'size/L',  max:  999 },
          { label: 'size/XL', max: Infinity },
        ];
        const sizeLabel = thresholds.find(t => changed <= t.max).label;

        // Remove other size/* then apply chosen
        const { data: existing } = await github.rest.issues.listLabelsOnIssue({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: pr.number,
        });
        const toRemove = existing
          .filter(l => l.name.startsWith('size/'))
          .map(l => l.name)
          .filter(n => n !== sizeLabel);

        if (toRemove.length) {
          await github.rest.issues.removeLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr.number,
            labels: toRemove,
          }).catch(() => {});
        }
        await github.rest.issues.addLabels({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: pr.number,
          labels: [sizeLabel],
        });

        core.summary
          .addHeading('PR Auto Labeler — Size')
          .addRaw(`Changed lines (excl. ignored globs): **${changed}** → **${sizeLabel}**`)
          .write();
```
