# ==============================================================================
# SpectraMind V50 — CI/Kaggle Makefile (Deterministic, Non‑Interactive)
# Use this in GitHub Actions / Kaggle to run a minimal, reproducible pipeline.
#
# Pipeline stages:
#   • validate → selftest → train(1 epoch, cpu) → diagnose → analyze
#   • (optional) validate-env, predict
#   • artifacts end up under outputs/ and logs/
# ==============================================================================

# ========= Shell =========
SHELL       := /usr/bin/env bash
.ONESHELL:
.SHELLFLAGS := -euo pipefail -c

# ========= Tooling =========
PYTHON      ?= python3
POETRY      ?= poetry
CLI         ?= $(POETRY) run spectramind

# ========= Paths / artifacts =========
OUT_DIR     ?= outputs
LOGS_DIR    ?= logs
DIAG_DIR    ?= $(OUT_DIR)/diagnostics
PRED_DIR    ?= $(OUT_DIR)/predictions

# ========= Fixed knobs for CI =========
DEVICE      ?= cpu
EPOCHS      ?= 1
OVERRIDES   ?=
EXTRA_ARGS  ?=

# ========= PHONY =========
.PHONY: help ci validate validate-env selftest train diagnose analyze predict dvc-pull dvc-push clean

help:
	@echo "make ci            # validate → selftest → train → diagnose → analyze"
	@echo "make predict       # optional: write submission.csv"
	@echo "make dvc-pull/push # sync DVC artifacts"
	@echo "make clean         # cleanup CI artifacts"

# Default target
ci: validate validate-env selftest train diagnose analyze

# Minimal validation (init dirs; add other quick checks here)
validate:
	mkdir -p "$(OUT_DIR)" "$(LOGS_DIR)" "$(DIAG_DIR)" "$(PRED_DIR)"
	@echo ">>> Validation complete (env/init)."

# Optional .env schema validator (safe no-op if missing)
validate-env:
	@if [ -x scripts/validate_env.py ] || [ -f scripts/validate_env.py ]; then \
	  echo ">>> Validating .env against schema"; \
	  $(PYTHON) scripts/validate_env.py || exit 1; \
	else \
	  echo ">>> Skipping validate-env (scripts/validate_env.py not found)"; \
	fi

selftest:
	@echo ">>> Selftest (fast, CI)"
	$(CLI) selftest --fast

train:
	@echo ">>> Train (CI deterministic: EPOCHS=$(EPOCHS), DEVICE=$(DEVICE))"
	$(CLI) train +training.epochs=$(EPOCHS) $(OVERRIDES) --device $(DEVICE) --outdir "$(OUT_DIR)" $(EXTRA_ARGS)

diagnose:
	@echo ">>> Diagnostics (CI)"
	$(CLI) diagnose smoothness --outdir "$(DIAG_DIR)" $(EXTRA_ARGS)
	# try a lightweight dashboard first, then full if needed
	$(CLI) diagnose dashboard --no-umap --no-tsne --outdir "$(DIAG_DIR)" $(EXTRA_ARGS) || \
	$(CLI) diagnose dashboard --outdir "$(DIAG_DIR)" $(EXTRA_ARGS) || true

analyze:
	@echo ">>> Analyze CLI logs (CI)"
	$(CLI) analyze-log --md "$(OUT_DIR)/log_table.md" --csv "$(OUT_DIR)/log_table.csv"

# Optional: ensure E2E path produces a submission artifact (kept deterministic)
predict:
	@echo ">>> Predict (CI optional)"
	$(CLI) predict --out-csv "$(PRED_DIR)/submission.csv" $(EXTRA_ARGS)
	@ls -lh "$(PRED_DIR)" || true

# Optional DVC pulls in CI
dvc-pull:
	dvc pull || true

dvc-push:
	dvc push || true

clean:
	rm -rf "$(OUT_DIR)" "$(DIAG_DIR)" "$(PRED_DIR)"
	rm -rf .pytest_cache .ruff_cache .mypy_cache
